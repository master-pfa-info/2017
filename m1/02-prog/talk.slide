Introduction to (imperative) programming
Master 1

Sebastien Binet
CNRS/IN2P3/LPC-Clermont
sebastien.binet@clermont.in2p3.fr

* Getting started

* Getting started

Computer programming is the art, craft and science of writing programs which define how computers operate.

We'll see how to write computer programs using a programming language designed by Google, named [[https://golang.org][Go]].

* Programming languages

Programming languages provide an *abstraction* from a computer's instruction set architecture

*Low-level* *programming* *languages* provide little or no abstraction, _e.g._ machine code and assembly language.

- Difficult to use
- Allows to program efficiently and with a low memory footprint

*High-level* *programming* *languages* isolate the executions semantics of a computer architecture from the specification of the program: this simplifies program development

* 

Machine code:

 8B542408 83FA0077 06B80000 0000C383
 C9010000 008D0419 83FA0376 078BD98B
 B84AEBF1 5BC3

Assembly:

 MOVQ 0x10(SP), AX	
 MOVQ 0x8(SP), CX	
 ADDQ CX, AX		
 MOVQ AX, 0x18(SP)	
 RET			

High-level language:

 func add(a, b int) int {
     return a+b
 }

* Principal programming paradigms

- imperative, procedural
- functional
- object oriented
- concurrent
- logic
- scripting

* Imperative programming ?

What does "imperative programming" mean ?

In the English language, an imperative is an instruction or command:
"Take me to your leader!"

.image _figs/take-me-to-your-leader.jpg 200 _

Similarly, in imperative programming, we use a *sequence* *of* *statements* (or "commands") to give _instructions_ to the computer.

* Elements of programming languages

Programming languages have many similarities with natural languages:

- rules for syntax, semantics
- many different dialects

* Compiled vs. Interpreted languages

*Compiled* languages are translated into machine code that can be run directly on a computer's processor: the whole program is translated before it's run.

*Interpreted* languages are processed by a higher-level virtual machine: the program is translated on the fly (_i.e._ a statement is translated and then immediately executed.)

.image _figs/compiled-interpreted.png 350 _

* Go

[[https://golang.org][Go]] is a compiled programming language: source code is translated into a language that the computer can understand.

So, before we can write a Go program, we need a Go compiler.

We can get one from:

.link https://golang.org/dl

This should have already been done for the machines we are using.

 $> go version
 go version go1.9 linux/amd64

The `go` program is made up of several different commands and sub-commands.
A list of those commands is available by typing:

 $> go help

* First program: hello world

Create a directory `hello` under `~/go/src`:

 $> cd
 $> mkdir -p ~/go/src/hello
 $> cd ~/go/src/hello

And then, create a new file `~/go/src/hello/main.go` with the following content:

.play _code/hello.go

We can then use `go` `run` to compile and execute this file:

 $> go run ./main.go
 hello world

* Go builtins

In high-level languages such as `C`, `C++`, `python` or `Go`, we don't deal directly with raw `bytes` to interact with the underlying machine code: we have abstractions.

This includes `types`.
In Go, we have *builtin* *types*, such as:

- `bool`: a type whose values are either `true` or `false`
- `int`: a signed integer (_e.g.:_ `0`, `-10`, `+10`, `42`, `666`)
- `uint`: an unsigned integer (_e.g.:_ `0`, `10`, `666`, ...)
- `float32`: a floating-point value encoded on 32 bits (_e.g.:_ `0.1`, `1e10`, `42.6`)
- `float64`: a floating-point value encoded on 64 bits (_e.g.:_ `0.1`, `1e10`, `42.6`)
- `string`: a chain of characters (_e.g.:_ `"hello"`, `"you"`, `"世界"`)
- `complex64`, `complex128`: a complex number (_e.g.:_ `1.0` `+` `2.0i`)

* 

Create a new program:

  $> mkdir -p ~/go/src/builtins
  $> cd ~/go/src/builtins
  $> nano main.go

You can start from:

.code _code/builtins-start.go

Eventually, the program shall display:

  $> go run ./main.go
  str= hello
  int= -42
  uint= 666
  f64= +2.500000e-001
  bool= true / false

* 

.play _code/builtins.go

* Variables

So far, we have printed values using "value literals".

That's not a technique that could _scale_ to very big programs: imagine if you had to write a program that computes the sum of all integers from `0` to `10000` and thus had to _literally_ write the sum `0+1+2` `...` `+10000`.
Pretty boring pretty quickly.

In most programming languages, we can store values inside entities, give them a name (or an identifier) and refer to them to recall their value.

In [[https://golang.org][Go]], that's done with the *keyword* `var`:

 var name string
 var age int
 var speed float64

The code above *declares* 3 variables, `name`, `age` and `speed` with the types (respectively), `string`, `int` and `float64` and values `""`, `0` and `0.0` (respectively.)

* 

Declaring a variable is thus:

 var [variable-name] [variable-type]

One can also initialize that variable with a default value:

 var name string = "electron"
 var charge int = -1
 var mass float64 = 0.511

Or, group many declarations in one "block":

 var (
     name   string  = "electron"
     charge int     = -1
     mass   float64 = 0.511
 )

* 

In [[https://golang.org][Go]], one can also let the compiler infer the type of a variable from the value we initialize it with:

 var (
     name   = "electron"
     charge = -1
     mass   = 0.511
 )
 var ok = false

`name` has type `string`, `charge` is an `int`, `mass` is still a `float64` and `ok` is a `bool`.

[[https://golang.org][Go]]'s inference type system can go even further:

 name := "electron"
 charge := -1
 mass := 0.511
 ok := false

* 

Create a new program `add/main.go`:

 $> mkdir -p ~/go/src/add
 $> cd ~/go/src/add
 $> nano main.go

Starting like so:

.code _code/add-start.go

Declare and initialize 2 variables `a` and `b`, of type `int` and with values `10` and `11` (resp.)
Print their sum.

Eventually, the program shall display:

 $> go run ./main.go
 a+b= 21

* 

.play _code/add.go

* Functions

One of the pillars of imperative programming is the concept of a *function*.
Functions allow to encapsulate a piece of algorithmic code, clearly defining the set of input data that it needs to operate and the output result of that piece of computation.

This piece of algorithmic code, cleanly encapsulated, can then be reused in other programs, by calling the function.

Let's revisit the `add` example:

.code _code/add.go

We could imagine wanting to encapsulate this addition of `a+b` and make it available for other programs.

* 

In [[https://golang.org][Go]], declaring and defining a function is done like this:

 func add(a int, b int) int {
     return a+b
 }

We use the keyword *func* to tell the compiler we are defining a new function, then comes the name of the function we are defining, the list of input parameters and their types, and finally, the type of the returned value.
Then comes the body of the function, its implementation.

 func [function-name]([input-params]) [output] { [body] }

* 

So the `add` example from earlier can be re-written like so:

.play _code/add-func.go

* 

Modify the `add` example from earlier and add the following functions:

- `mul`: takes 2 integers and returns their product
- `div`: takes 2 integers and returns their division

Modify `main` to display:

- `add(a,b)`
- `mul(a,b)`
- `div(a,b)`
- `mul(mul(a,b),div(a,b))`

Try different values of `a` and `b`:

- `a=10`, `b=11`
- `a=10`, `b=5`
- `a=10`, `b=0`

Anything peculiar?

* 

Modify the previous program and define the following functions: `fadd`, `fmul` and `fdiv`.
They should do the same than their `add`, `mul` and `div` counter-parts (except they operate on `float64` values.)

Modify `main` to define 2 new `float64` variables `x` and `y` and to display:

- `fadd(x,y)`
- `fmul(x,y)`
- `fdiv(x,y)`
- `fmul(fmul(x,y),fdiv(x,y))`

Try different values of `x` and `y`:

- `x=10.0`, `y=11.0`
- `x=10.0`, `y=5.0`
- `x=10.0`, `y=0.0`

* 

Modify the previous program to define a new function `fma` (fused multiply-add) that takes 3 `float64` arguments and returns `x*y+z`.
Except that you should implement it using `fmul` and `fadd`.

Display the result of `fma(x,y,2.0)`.

* Arrays and Slices

So far we've seen how to declare and use variables of builtin types (`int`, `float64`, ...)

But in real life, we usually have to deal with variables of more than just one value: a collection of values (of the same type.)

_E.g.:_ a collection of energy deposits in a calorimeter, a collection of hits positions in a tracker, the list of names of a students' class, etc...

In [[https://golang.org][Go]], collections of items come in two flavours:

- static arrays: arrays whose number of elements are known and *fixed* at compile time
- dynamic arrays: arrays whose number of elements are not known beforehand and can be resized at run time.

* Arrays

Arrays in Go are static arrays.
Their size is fixed and can not be neither extended nor shrunk.

 var a [10]int
 var b [1]float64
 var c = [3]int{1, 2, 3}
 d := [3]int{10, 20, 30}
 e := [...]int{10, 20, 30}

One can access the first element of an array `arr` with:

 arr := [10]int{0, 2, 4, 6, 8, 10, 12, 14, 16, 18}
 e1 := arr[0] // first element. value==0

One can also use the builtin function `len` to retrieve the size of an array:

 size := len(arr) // here, size==10

So to access the last element of an array:

 e10 := arr[len(arr)-1] // value==18

* 

Write a new program, in `~/go/src/arr/main.go`, that creates an array of 3 unsized integers, from 10 to 12.
Print each element of the array and then modify the element at index 1 to the new value 42.
Re-print each element of the array.

The program shall print:

 arr[0]= 10
 arr[1]= 11
 arr[2]= 12
 arr[0]= 10
 arr[1]= 42
 arr[2]= 12

* Slices

Slices in Go are dynamic arrays.
Their size is not necessarily known at compile time and can change during the execution of the program.

 var a []float64             // a slice with 0 element
 var b = []int{1, 2, 3}      // a slice with 3 elements
 c := []int{10, 20, 30}      // a slice with 3 elements
 var d = make([]float64, 10) // a slice with 10 elements (all zeros)
 e := make([]float64, 10)    // a slice with 10 elements (all zeros)

`make` is a builtin function of [[https://golang.org][Go]] that allocates the needed memory to hold the requested number of elements of the given type:

 slice := make([]T, nelemts)

* 

Element access and modification are performed the same as for arrays:

 a := []int{0, 2, 4, 6, 8, 10, 12, 14, 16, 18}
 e1 := a[0] // first element. value == 0
 size := len(a) // ==10
 a[1] = 42

To add a new element at the end of a slice:

 a = append(a, 20)
 size = len(a) // ==11
 a = append(a, 22, 24)
 size = len(a) // ==13

* 

One can also sub-slice a slice (take a sub-sample of the original slice):

 a := []int{1, 2, 3, 4, 5}
 b := a[1:3]           // == {2, 3}
 c := a[0:2]           // == {1, 2}
 d := a[:3]            // == {1, 2, 3}
 e := a[1:]            // == {2, 3, 4, 5}
 f := a[:]             // == {1, 2, 3, 4, 5}

*NOTE:* a slice and its sub-slice *share* the same underlying backing array:

 a := []int{1, 2, 3, 4}
 b := a[1:3]  // == {2, 3}
 b[0] = 3
 println(b[0], b[1])       // 3 3
 println(a[0], a[1], a[2]) // 1 3 3

* 

Write a new program, in `~/go/src/sli/main.go`, that creates an empty slice of `float64` and then appends 3 new values: `1.2`, `3.4` and `5.6`.
Print the 3 values, increase `sli[2]` by `1` and reprint the values.

The program shall display:

  sli[0]= +1.200000e+000
  sli[1]= +3.400000e+000
  sli[2]= +5.600000e+000
  sli[0]= +1.200000e+000
  sli[1]= +3.400000e+000
  sli[2]= +6.600000e+000

What does happen if you try to access `sli[3]` ?

* Control flow structures

So far our programs have been pretty boring and linear.
They were a very straightforward list of instructions, that the CPU would execute one after the other.
Very predictable. Very linear.

But in real life, we usually want our programs to do different things depending on the value(s) of some variable(s).

This is achieved with an `if`-statement.

 if len(array) > 10 {
   println("array is big")

 } else if len(array) == 1 {
   println("array length is just one")
 
 } else {
   println("array is rather small")
 }

* 

.play _code/if-else.go

* Control flow structures

Another useful control flow structure is the `for`-loop:

 for i := 0; i < 10; i++ {
     println("i=", i)
 }

or, the version iterating on a slice:

 vs := []int{0, 2, 4, 6, 8}
 for i := range vs {
     println("i=", i, "==>", vs[i])
 }

or:

 vs := []int{0, 2, 4, 6, 8}
 for i, v := range vs {
     println("i=", i, "==>", v)
 }

* 

.play _code/for-loops.go

* 

Write a new program, in `~/go/src/for-loop/main.go`, that will define a function `squares` that:

- takes an integer `n` as input
- returns a slice of length `n` and content the squares of the index

Create another function `sum` that takes a slice of integers and returns the sum of all the elements of the input slice.

Edit `main` so that it calls `sum` for all the integers from `0` to `20` (excluded) and prints both the argument of `sum` and the result of `sum`.

* 

Write a new program, in `~/go/src/sum-even/main.go`, that defines a function `sum` that:

- takes a slice of integers as input
- returns the sum of all the even elements from that input slice

Edit `main` so that it calls `sum` for all the integers from `0` to `20` (excluded), generates a slice of integers from `0` to `i`, and prints the value of `i` and the result of `sum(slice)`.

* Packages and functions

So far, we've only seen how to create a single binary application/program.
We compiled that one `main.go` file (through `go` `run`) and ran.

Everything we needed for our `main` function was defined inside `main.go`.

In real life, we'd rather:

- create re-usable pieces of functionalities
- group them by theme and package them as libraries (_a.k.a.:_ `"packages"` in Go)

Then, people can `import` these libraries and the functions defined there in their own programs (or libraries.)

The [[https://golang.org][Go]] programming language comes with a rather large set of packages, usually called the "standard library" (_a.k.a.:_ "stdlib".)

* Standard library

The documentation for [[https://golang.org][Go]]'s standard library is available on:

.link https://golang.org/pkg

It's quite extensive.

Let's inspect and use the `"math"` and `"fmt"` package:

.link https://golang.org/pkg/math
.link https://golang.org/pkg/fmt

* 

.play _code/stdlib-pkg.go

* Package

Let's create our first package.

Create a new file `~/go/src/uca.fr/ints/ints.go` with the following content:

.code _code/ints-pkg.go

* 

Now, create a new program in `~/go/src/sum-2/main.go`, and edit `main` such that:

- it creates a slice of `20` elements, calling `ints.Gen(20)`,
- it prints its content
- it prints the result of calling `ints.Sum(slice)`, using the `"fmt"` package from the standard library.

_NB:_ importing our `"ints"` package is done like so:

 import "uca.fr/ints"

* 

As a simple way to play with functions and loops, implement the square root function using Newton's method.

In this case, Newton's method is to approximate Sqrt(x) by picking a starting point z and then repeating:

.image _figs/newton.png

To begin with, just repeat that calculation 10 times and see how close you get to the answer for various values (1, 2, 3, ...).

Next, change the loop condition to stop once the value has stopped changing (or only changes by a very small delta).
See if that's more or fewer iterations.
How close are you to the `math.Sqrt`?

* 

.code _code/newton-start.go

* Interlude: Monte Carlo simulations

.link https://en.wikipedia.org/wiki/Monte_Carlo_method

Monte Carlo methods are useful for simulating systems with many coupled degrees of freedom.
In many HEP experiments, we use [[http://geant4.cern.ch/][GEANT]] to simulate the interactions of particules through detectors.
`GEANT` simulates step-by-step the interactions of particules through matter and the energy deposits.

The simulation of physics processes with GEANT is very detailed but, also, very CPU hungry.
(That's why we usually run so called "fast simulation" programs, with a less detailed description of the physics processes.)

Let's do that.

* Introduction to Monte Carlo methods

We'll first try to approximate Pi using the Monte-Carlo method.

Consider a circle inscribed in a unit square.
Given that the circle and the square have a ratio of areas that is π/4, the value of  π can be approximated using a Monte-Carlo method:

- draw a square, inscribe a circle within it,
- uniformly scatter objects of uniform size over the square,
- count the number of objects inside the circle and the total number of objects,
- the ratio of the inside-count and the total-sample-count is an *estimate* of the ratio of the two areas, which is π/4.

Multiply the result by 4 to estimate π.


* 

Let's write a new program under `~/go/src/mc-pi/main.go`, starting with:

.code _code/mc-pi-start.go

* 

Have a look at the documentation of `math/rand` (for drawing random numbers):

.link https://golang.org/pkg/math/rand

Then, try with different values for `n`:

 $> go run ./main.go -n 10
 $> go run ./main.go -n 1000
 $> ...

*

Let's add some graphics:

.link https://godoc.org/github.com/master-pfa-info/mcpi

The `mcpi` package is a rather simple package that draws `(x,y)` points in the plane `((0,0), (1,1))`.


* 

Let's add some graphics and (limited) interactivity to our program.

We'll use the [[https://godoc.org/github.com/master-pfa-info/mcpi][master-pfa-info/mcpi]] package to plot the `(x,y)` points inside our quarter of a circle.

.link https://github.com/master-pfa-info/mcpi

As the documentation in the link above says, we need to install that library, using the following command (in the shell):

 $> go get github.com/master-pfa-info/mcpi

* 

Modify the previous program to plot the `(x,y)` points, using the `mcpi.Plot(x,y)` function:

.code _code/mc-pi-plot-start.go

* 

.image _figs/mc-pi.png 600 _

* Pointers & Structs

* Pointers

[[https://golang.org][Go]] supports one more builtin type: pointers.

A pointer is a variable whose value contains the address of another variable:

.play _code/ptr-0.go

* 

.play _code/func-no-ptr.go

* Interlude: implementing a calculator

* 

Let's create a new program, `~/go/src/calc/main.go`.
Our calculator will take numbers (integers) from the command line and will display their sum:

  $> cd ~/go/src/calc
  $> go build
  $> ./calc 1 2 3 4 100
  sum= 110

So far, all our programs were nice little isolated islands: they working by themselves, displaying output informations with minimal to no interactions with the outside world.

How can we somehow "connect" data from the outside with our program?

One way is to pass information from the outside via the command line, when the program is invoked.

* os.Args

In [[https://golang.org][Go]], arguments given to the program when invoked are accessible via the `os.Args` slice of strings:

 $> go doc os.Args
 var Args []string
     Args hold the command-line arguments, starting with the program name.

Let's start with:
.play _code/calc-01.go

* 

Try:

 $> go build
 $> ./calc
 args: 1
 args[0] = "./calc"

 $> ./calc 1 2 foo 42.3 bar
 args: 6
 args[0] = "./calc"
 args[1] = "1"
 args[2] = "2"
 args[3] = "foo"
 args[4] = "42.3"
 args[5] = "bar"

* 

Let's modify `main.go` to also print the argument type (with `"%T"`):

.play _code/calc-02.go

* 

  $> ./calc 1 2 foo 42.3 bar
  args: 6
  args[0] = "./calc" (string)
  args[1] = "1" (string)
  args[2] = "2" (string)
  args[3] = "foo" (string)
  args[4] = "42.3" (string)
  args[5] = "bar" (string)

So for our calculator project, we need to somehow convert the strings to integers.

In [[https://golang.org][Go]] this can be done with the [[https://golang.org/pkg/strconv][strconv]] package from the stdlib:

  v, err := strconv.Atoi("42")
  if err != nil {
      panic(err)
  }

Don't fret about the `err` and the `panic` for now.
We'll come back to this in the next chapter.

* 

So now, go write the calculator!

It should behave like so:

  $> cd ~/go/src/calc
  $> go build
  $> ./calc 1 2 3 4 100
  sum= 110

* 

We know have a great tool at our disposal.
But it's quite blunt:

- no way to ask help and usage
- no way to customize its behaviour (_e.g.:_ enable a verbose mode)

We need a way to pass parameters, "flags", that can tweak the runtime behaviour of our great calculator, like we did with:

 $> ls -l
 $> ls -F
 $> find . -type d

In [[https://golang.org][Go]], this can be done with the [[https://golang.org/pkg/flag][flag]] package.

* 

A typical usage would look like:

.code _code/flag-pkg.go

* 

 $> go build -o flag-ex ./flag-example.go
 $> ./flag-ex
 verbose=   false
 pt-min=    25.000000
 b-tag=     2
 os.Args=   [./flag-ex]
 flag.Args= []
 
 $> ./flag-ex -btag 3 -v -pt-min=0.1 foo bar
 verbose=   true
 pt-min=    0.100000
 b-tag=     3
 os.Args=   [./flag-ex -btag 3 -v -pt-min=0.1 foo bar]
 flag.Args= [foo bar]

 $> ./flag-ex -h
 Usage of ./flag-ex:
   -btag int
     	number of b-tag for H->bb analysis (default 2)
   -pt-min float
     	min Pt cut for H->bb analysis (default 25)
   -v	enable verbose mode

* 

Now, modify our super calculator so that it accepts a `"-v"` flag that enables a verbose mode (and is false by default):

 $> ./calc 1 2 3 4 100
 sum= 110

 $> ./calc -v 1 2 3 4 100
 0
 + 1 -> 1
 + 2 -> 3
 + 3 -> 6
 + 4 -> 10
 + 100 -> 110
 ===============
 sum= 110


* Structs

* Interlude: Lorentz vectors

* Lorentz vectors

How would you create a library that would deal with Lorentz vectors ?

* 

Using 4 variables ?

  var px, py, pz, e float64

Then perhaps, the functions to compute the mass and add 2 4-vectors:

  func mass(px, py, pz, e float64) float64 {
      m2 := e*e - (px*px + py*py + pz*pz)
      return math.Sqrt(m2)
  }

  func add(px1, py1, pz1, e1, px2, py2, pz2, e2 float64) (px, py, pz, e float64) {
      return px1+px2, py1+py2, pz1+pz2, e1+e2
  }

But then you have to carry around those 4 `float64` everywhere together.

* 

What if you want to compute the invariant mass of 2 particles, say a `Z->bb` ?

You need:

  var b1px, b1py, b1pz, b1e float64 // b-jet #1
  var b2px, b2py, b2pz, b2e float64 // b-jet #2

and then:

  zpx, zpy, zpz, ze := add(b1px, b2px, b1py, b2py, b1pz, b2pz, b1e, b2e) // OOPS. BUG.
  invMass := mass(zpx, zpy, zpz, ze)


* 

Or perhaps using an array of 4 `float64` ?

  var p4 [4]float64

  func mass(p [4]float64) float64 {
      m2 := p[3]*p[3] - (p[0]*p[0] + p[1]*p[1] + p[2]*p[2])
      return math.Sqrt(m2)
  }

  func add(p1, p2 [4]float64) [4]float64 {
      return [4]float64{p1[0]+p2[0], p1[1]+p2[1], p1[2]+p2[2], p1[3]+p2[3]}
  }


* 

Our `Z->bb` example becomes:

  var (
     b1, b2 [4]float64

     z       = add(b1, b2)
     invMass = mass(z)
  )

But then, how do you make sure everybody is using the same convention ?

  [4]float64 == {px, py, pz, ene}

and not, _e.g.:_

  [4]float64 == {ene, px,  py,  pz}
  [4]float64 == {ene, eta, phi, mass}
  [4]float64 == {pt,  eta, phi, mass}
  ...

We need a way to bundle multiple values together *and* still attach some meaning (or give context) to these values...

* Structs

In [[https://golang.org][Go]] (and other languages), this task can be addressed with a `struct`:

  type P4 struct {
      Px, Py, Pz, E float64
  }

  func mass(p P4) float64 {
      m2 := p.E*p.E - (p.Px*p.Px + p.Py*p.Py + p.Pz*p.Pz)
      return math.Sqrt(m2)
  }

  func add(p1, p2 P4) P4 {
      return P4{p1.Px+p2.Px, p1.Py+p2.Py, p1.Pz+p2.Pz, p1.E+p2.E}
  }

* 

Like for the other declarations, the new type declaration of a struct is:

  type [[new-name]] struct { [[definition]] }

Fields of a struct can be of different types:

  type P4 struct { Px, Py, Pz, E float64 }
  type RecoParticle struct {
      Momentum P4          // reconstructed momentum of the particle
      Charge   float64     // charge of the particle
      AlgName  string      // algorithm that reconstructed the particle
      PDGID    int         // Particle Data Group ID
      McTruth  *McParticle // pointer to MonteCarlo truth (simu-only)
  }

A struct can also have no field:

  type Empty struct {}

* 

Let's write a program that can handle planar geometry (_ie:_ 2D).

Create a package (not a program), named `geo2d` under `~/go/src/uca.fr/geo2d/geo.go`.

In that package, create 2 structs:

- a structure named `Point` with 2 fields of type `float64` that will store the `X` and `Y` coordinates of the Point,
- a structure named `Rect` with 3 fields: the `Orig` (the bottom-most, left-most corner of the rectangle), the `Width` and the `Height` of the rectangle.

  +-----------+
  |<--Width-->| ^
  |           | Height
  |           | v
  +-----------+
  Orig

* 

Implement:

  // Translate returns a new Point translated by dx and dy
  func Translate(pt Point, dx float64, dy float64) Point { ... }

  // Area returns the area of the given rectangle
  func Area(rect Rect) float64 { ... }
  
  // Perimeter returns the perimeter of the given rectangle
  func Perimeter(rect Rect) float64 { ... }

  // Contains returns whether the given rectangle contains the given point
  func Contains(rect Rect, pt Point) bool { ... }

  // Overlap returns whether 2 rectangles overlap
  func Overlap(r1, r2 Rect) bool { ... }


* 

To test your package `geo2d` actually works, run the following program:

.play _code/geo2d-test.go

* I/O

* Working with files

Programming languages provide a way to:

- create files,
- open files for read-access,
- open files for write-access,
- iterate over the content of a file on disk (and possibly modify that content.)

In [[https://golang.org][Go]], this is done (mostly) with the [[https://golang.org/pkg/os][os]] package.

  f, err := os.Open("data.txt")
  if err != nil {
      panic(err)
  }

On the disk, a file is just a sequence of `bytes`.

Quite naturally, [[https://golang.org][Go]] will represent this data (to be read from a file or written to a file) as a `[]byte`, a slice of `bytes`.


* 

Let's create a new program `~/go/src/create-file/main.go` with the following content:

.code _code/create-file.go HLxxx

* 

Running this program should give:

 $> go run ./main.go
 
 $> cat data.txt
 hello world
 0 1 2 3 4 5
 good bye

Creating/opening a file, writing to the file, reading from the file and/or closing the file *MAY* fail for some reason (not enough disk space, corrupted filesystem, broken hard disk, no more network connection, etc...)

That's why most of the function that deal with files return this extra `err` value (of type `error`.)

We'll see in more details what an `error` type is in the chapter about `interfaces`.
For now, remember to always `Close()` your files whenever you've opened them (for reading or writing), and always check whether that `error` value is not `nil`.

* 

Let's modify `~/go/src/create-file/main.go` like so:

.code _code/create-file-floats.go

* 

Running this program should give:

 $> go run ./main.go

 $> head -n 4 data.txt
 -1.233758177597947
 -0.12634751070237293
 -0.5209945711531503
 2.28571911769958

 $> wc ./data.txt 
  1000  1000 19671 ./data.txt


Now create yet another program, `~/go/src/read-file/main.go` with the following content (see next slide.)

* 

.code _code/read-file-floats.go

* 

Copy the `data.txt` file created previously into the current directory.
Running our new program should give:

 $> go run ./main.go
 mean= -0.013051

* 

Hard-coding the number of times to loop over the lines in the input file isn't quite satisfactory.

Let's try to fix that.
In [[https://golang.org][Go]], there is a special type that can scan lines of a files and iteratively present each line as an API:

  f, err := os.Open("some-file.txt")
  if err != nil { panic(err) }
  scan := bufio.NewScanner(f)  // need to import "bufio"

  for scan.Scan() {
    txt := scan.Text() // returns a string with the content of current line.
    fmt.Printf("we've read line %q\n", txt)
  }

  if err = scan.Err(); err != nil { panic(err) }
  if err = f.Close();  err != nil { panic(err) }

.link https://golang.org/pkg/bufio#Scanner

* 

Wielding this new tool at our disposal, let's modify the previous program (`read-file/main.go`) to not hard-code the number of times/lines to loop over when reading the input file.

In the previous version of that program, we used `fmt.Fscanf` to extract a `float64` out of the file.
Now we need to extract a `float64` out of a line (which is a `string`.)

We'll need to use a slightly different function to do that: `fmt.Sscanf`.

.link https://golang.org/pkg/fmt#Sscanf

 for scan.Scan() {
     var f64 float64
     var txt = scan.Text()
     _, err = fmt.Sscanf(txt, "%f", &f64)
     if err != nil { panic(err) }
 }

* 

Make sure we still get the same answer when running the new version of the program:

 $> go run ./main.go
 mean= -0.013051


* Solution

.code _code/read-file-floats-bufio.go /^func main/,/^}/

* 

Create a new program `~/go/src/write-2d-gauss/main.go`.
It should create a new `data-2d-gauss.txt` file containing 2 columns of data.

Each column should be a 1000-sample of (respectively):

- a gaussian with mean 20 and standard deviation 5
- a gaussian with mean 10 and standard deviation 20.

Create another program `~/go/src/read-2d-gauss/main.go`, that will:

- read the previously created `data-2d-gauss.txt` file,
- store the data for each column in a dedicated slice of `float64`,
- define 2 functions `mean` and `stddev` that take a `[]float64` slice as input and return (respectively) the mean and the standard deviation of the slice.

Make sure you get the expected mean and stddev values for each sample.

* 

Let's revisit our super calculator.

Modify the calculator to be able to sum `float64` values (and not just `int` as previously.)

Add 2 new flags:

 var flagFile = flag.String("f", "", "path to a file holding values")
 var flagStats = flag.Bool("stats", false, "enable computation+display of stats")

Modify the calculator to be able to optionally take a path to a file (with `-f=my-file.txt`) and then take data from that file instead of from the command line like previously.

Make sure that it still works as previously when no `-f` flag is passed (_ie:_ when `*flagFile==""`).

Use a `bufio.Scanner` to read the (optional) input file.

* 

Modify the calculator to compute the mean and standard deviation of the input data when the `-stats` flag is passed to the program.
When that flag is passed, the calculator should display the mean and std-dev of the sample at the end of the program.
It should work for both modes (when `*flagFile==""` and when a path to a file is given to the program.)

* Object Oriented Programming

* Structs, Types & Methods

Do you remember the Lorentz vectors we defined earlier ?

  type P4 struct {
      Px, Py, Pz, E float64
  }

  func mass(p P4) float64 {
      m2 := p.E*p.E - (p.Px*p.Px + p.Py*p.Py + p.Pz*p.Pz)
      return math.Sqrt(m2)
  }

  func add(p1, p2 P4) P4 {
      return P4{p1.Px+p2.Px, p1.Py+p2.Py, p1.Pz+p2.Pz, p1.E+p2.E}
  }

* 

Let's modify it a little bit:

  type PxPyPzE struct {
      px, py, pz, e float64
  }

  func mass(p PxPyPzE) float64 {
      m2 := p.e*p.e - (p.px*p.px + p.py*p.py + p.pz*p.pz)
      return math.Sqrt(m2)
  }

  func add(p1, p2 PxPyPzE) PxPyPzE {
      return PxPyPzE{p1.px+p2.px, p1.py+p2.py, p1.pz+p2.pz, p1.e+p2.e}
  }

and add:

  type PtEtaPhiM struct {
      pt, eta, phi, m float64
  }

* 

When we add another Lorentz vector type (with different components) we have a problem:

- we can't call the `mass(...)` function on a `PtEtaPhiM` value as `add` expects a  `PxPyPzE`.

We could define 2 functions:

 func massPxPyPzE   (p PxPyPzE  ) float64 { ... }
 func massPtEtaPhiM (p PtEtaPhiM) float64 { ... }

But we can do better: define methods on each type `PxPyPzE` and `PtEtaPhiM`:

 func (p PxPyPzE)   Mass() float64 { ... }
 func (p PtEtaPhiM) Mass() float64 { ... }

What did we gain here ?

* 

.play _code/hlv-main.go /^func main/,/^}/ HLxxx
.play _code/hlv-main-meth.go /^func main/,/^}/ HLxxx

* 

We can also define a new method on the type `PxPyPzE`:

.play _code/hlv-main-meth-stringer.go /^func \(p PxPyPzE\) String\(/,/^}/

and then:

.play _code/hlv-main-meth-stringer.go /^func main/,/^}/ HLxxx

* 

What did just happen ?

The `fmt.Printf` function managed to call the method `String()` of our `PxPyPzE` value.
When `fmt.Printf` was written (~10 years ago),

- it didn't know a type like `PxPyPzE` would ever be written,
- it didn't even know it would have a method with that name and signature!

Yet, somehow it knew it had to call `String()` on our `z` value...

Well... that's because `fmt.Printf` used an *interface* and because our `PxPyPzE` (implicitly) implemented it.

* Interfaces

An interface type is defined as a set of method signatures.

A value of interface type can hold any value that implements those methods.

  type Abser interface {
      Abs() float64
  }
  
  type Reader interface {
      Read(data []byte) (int, error)
  }


_E.g.:_ the type `MyFloat` implements the `Abser` interface:

  type MyFloat float64
  
  func (f MyFloat) Abs() float64 {
  	if f < 0 {
  		return float64(-f)
  	}
  	return float64(f)
  }

* Interfaces

Modify the code below to make `MyFloat` and `Vertex` implement the `Abser` interface:

.play _code/ex-interfaces.go /STARTABSER OMIT/,/ENDABSER OMIT/

* Solution

.play _code/ex-interfaces.go /STARTABSERIMPL OMIT/,/ENDABSERIMPL OMIT/

* 

Interfaces are useful to write code that can use code that hasn't been written yet.

  func Selector(a Abser) bool {
      if a.Abs() > 2.5 {
          return true
      }
      return false
  }

  func do() {
    Selector(MyFloat(42))    // this compiles.
    Selector(&Vertex{1,2})   // this also compiles.
    Selector(Vertex{1,2})    // but this does NOT compile.
  }


The `Selector` function can be used with values of types `MyFloat`, `Vertex` or any other type (possibly one written 15 years from now) that implements the `Abser` interface.

And no need to modify nor adapt the `Selector` function to get it working with these new types, as long as they implement the `Abser` interface.

It's a contract that binds the 2 parties (the interface and the type that implements that interface.)

* 

Let's revisit our `geo2d` package.

We had defined 2 types: `Point` and `Rect`.

Let's introduce 1 new type: `Circle`.

Define 2 new interfaces:

  type Surfer interface {
      // Surf returns the surface of a 2D shape
      Surf() float64
  }

  type Stringer interface {
      // String returns a string reprensation of a value.
      String() string
  }

* 

Modify `geo2d` such that `Point`, `Rect` and `Circle` implement the `Stringer` interface.

Modify `geo2d` such that `Rect` and `Circle` implement the `Surfer` interface.

Finally, modify the `geo2d.Area` function to take a `Surfer` parameter instead of a `Rect`.
Test that you can then pass both a value of type `Circle` and of type `Rect` to this new function `Area`.

* 

Interfaces are a very powerful abstraction.

They are actually one of the building blocks of OO-programming in [[https://golang.org][Go]].


* Resources

.link https://golang-book.com
.link http://www.inf.unibz.it/dis/teaching/PP/ln/pp01_intro.pdf
.link http://www.inf.unibz.it/dis/teaching/PP/ln/pp02_oo.pdf
.link https://tour.golang.org
.link https://www.golangbootcamp.com/book

