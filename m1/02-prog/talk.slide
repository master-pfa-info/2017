Introduction to (imperative) programming
Master 1

Sebastien Binet
CNRS/IN2P3/LPC-Clermont
sebastien.binet@clermont.in2p3.fr

* Getting started

* Getting started

Computer programming is the art, craft and science of writing programs which define how computers operate.

We'll see how to write computer programs using a programming language designed by Google, named [[https://golang.org][Go]].

* Programming languages

Programming languages provide an *abstraction* from a computer's instruction set architecture

*Low-level* *programming* *languages* provide little or no abstraction, _e.g._ machine code and assembly language.

- Difficult to use
- Allows to program efficiently and with a low memory footprint

*High-level* *programming* *languages* isolate the executions semantics of a computer architecture from the specification of the program: this simplifies program development

* 

Machine code:

 8B542408 83FA0077 06B80000 0000C383
 C9010000 008D0419 83FA0376 078BD98B
 B84AEBF1 5BC3

Assembly:

 MOVQ 0x10(SP), AX	
 MOVQ 0x8(SP), CX	
 ADDQ CX, AX		
 MOVQ AX, 0x18(SP)	
 RET			

High-level language:

 func add(a, b int) int {
     return a+b
 }

* Principal programming paradigms

- imperative, procedural
- functional
- object oriented
- concurrent
- logic
- scripting

* Imperative programming ?

What does "imperative programming" mean ?

In the English language, an imperative is an instruction or command:
"Take me to your leader!"

.image _figs/take-me-to-your-leader.jpg 200 _

Similarly, in imperative programming, we use a *sequence* *of* *statements* (or "commands") to give _instructions_ to the computer.

* Elements of programming languages

Programming languages have many similarities with natural languages:

- rules for syntax, semantics
- many different dialects

* Compiled vs. Interpreted languages

*Compiled* languages are translated into machine code that can be run directly on a computer's processor: the whole program is translated before it's run.

*Interpreted* languages are processed by a higher-level virtual machine: the program is translated on the fly (_i.e._ a statement is translated and then immediately executed.)

.image _figs/compiled-interpreted.png 350 _

* Go

[[https://golang.org][Go]] is a compiled programming language: source code is translated into a language that the computer can understand.

So, before we can write a Go program, we need a Go compiler.

We can get one from:

.link https://golang.org/dl

This should have already been done for the machines we are using.

 $> go version
 go version go1.9 linux/amd64

The `go` program is made up of several different commands and sub-commands.
A list of those commands is available by typing:

 $> go help

* First program: hello world

Create a directory `hello` under `~/go/src`:

 $> cd
 $> mkdir -p ~/go/src/hello
 $> cd ~/go/src/hello

And then, create a new file `~/go/src/hello/main.go` with the following content:

.play _code/hello.go

We can then use `go` `run` to compile and execute this file:

 $> go run ./main.go
 hello world

* Go builtins

In high-level languages such as `C`, `C++`, `python` or `Go`, we don't deal directly with raw `bytes` to interact with the underlying machine code: we have abstractions.

This includes `types`.
In Go, we have *builtin* *types*, such as:

- `bool`: a type whose values are either `true` or `false`
- `int`: a signed integer (_e.g.:_ `0`, `-10`, `+10`, `42`, `666`)
- `uint`: an unsigned integer (_e.g.:_ `0`, `10`, `666`, ...)
- `float32`: a floating-point value encoded on 32 bits (_e.g.:_ `0.1`, `1e10`, `42.6`)
- `float64`: a floating-point value encoded on 64 bits (_e.g.:_ `0.1`, `1e10`, `42.6`)
- `string`: a chain of characters (_e.g.:_ `"hello"`, `"you"`, `"世界"`)
- `complex64`, `complex128`: a complex number (_e.g.:_ `1.0` `+` `2.0i`)

* 

Create a new program:

  $> mkdir -p ~/go/src/builtins
  $> cd ~/go/src/builtins
  $> nano main.go

You can start from:

.code _code/builtins-start.go

Eventually, the program shall display:

  $> go run ./main.go
  str= hello
  int= -42
  uint= 666
  f64= +2.500000e-001
  bool= true / false

* Solution

.play _code/builtins.go

* Variables

So far, we have printed values using "value literals".

That's not a technique that could _scale_ to very big programs: imagine if you had to write a program that computes the sum of all integers from `0` to `10000` and thus had to _literally_ write the sum `0+1+2` `...` `+10000`.
Pretty boring pretty quickly.

In most programming languages, we can store values inside entities, give them a name (or an identifier) and refer to them to recall their value.

In [[https://golang.org][Go]], that's done with the *keyword* `var`:

 var name string
 var age int
 var speed float64

The code above *declares* 3 variables, `name`, `age` and `speed` with the types (respectively), `string`, `int` and `float64` and values `""`, `0` and `0.0` (respectively.)

* 

Declaring a variable is thus:

 var [variable-name] [variable-type]

One can also initialize that variable with a default value:

 var name string = "electron"
 var charge int = -1
 var mass float64 = 0.511

Or, group many declarations in one "block":

 var (
     name   string  = "electron"
     charge int     = -1
     mass   float64 = 0.511
 )

* 

In [[https://golang.org][Go]], one can also let the compiler infer the type of a variable from the value we initialize it with:

 var (
     name   = "electron"
     charge = -1
     mass   = 0.511
 )
 var ok = false

`name` has type `string`, `charge` is an `int`, `mass` is still a `float64` and `ok` is a `bool`.

[[https://golang.org][Go]]'s inference type system can go even further:

 name := "electron"
 charge := -1
 mass := 0.511
 ok := false

* 

Create a new program `add/main.go`:

 $> mkdir -p ~/go/src/add
 $> cd ~/go/src/add
 $> nano main.go

Starting like so:

.code _code/add-start.go

Declare and initialize 2 variables `a` and `b`, of type `int` and with values `10` and `11` (resp.)
Print their sum.

Eventually, the program shall display:

 $> go run ./main.go
 a+b= 21

* Solution

.play _code/add.go

* Functions

One of the pillars of imperative programming is the concept of a *function*.
Functions allow to encapsulate a piece of algorithmic code, clearly defining the set of input data that it needs to operate and the output result of that piece of computation.

This piece of algorithmic code, cleanly encapsulated, can then be reused in other programs, by calling the function.

Let's revisit the `add` example:

.code _code/add.go

We could imagine wanting to encapsulate this addition of `a+b` and make it available for other programs.

* 

In [[https://golang.org][Go]], declaring and defining a function is done like this:

 func add(a int, b int) int {
     return a+b
 }

We use the keyword *func* to tell the compiler we are defining a new function, then comes the name of the function we are defining, the list of input parameters and their types, and finally, the type of the returned value.
Then comes the body of the function, its implementation.

 func [function-name]([input-params]) [output] { [body] }

* 

So the `add` example from earlier can be re-written like so:

.play _code/add-func.go

* 

Modify the `add` example from earlier and add the following functions:

- `mul`: takes 2 integers and returns their product
- `div`: takes 2 integers and returns their division

Modify `main` to display:

- `add(a,b)`
- `mul(a,b)`
- `div(a,b)`
- `mul(mul(a,b),div(a,b))`

Try different values of `a` and `b`:

- `a=10`, `b=11`
- `a=10`, `b=5`
- `a=10`, `b=0`

Anything peculiar?

* 

Modify the previous program and define the following functions: `fadd`, `fmul` and `fdiv`.
They should do the same than their `add`, `mul` and `div` counter-parts (except they operate on `float64` values.)

Modify `main` to define 2 new `float64` variables `x` and `y` and to display:

- `fadd(x,y)`
- `fmul(x,y)`
- `fdiv(x,y)`
- `fmul(fmul(x,y),fdiv(x,y))`

Try different values of `x` and `y`:

- `x=10.0`, `y=11.0`
- `x=10.0`, `y=5.0`
- `x=10.0`, `y=0.0`

* Solution

.play _code/fadd.go

* 

Modify the previous program to define a new function `fma` (fused multiply-add) that takes 3 `float64` arguments and returns `x*y+z`.
Except that you should implement it using `fmul` and `fadd`.

Display the result of `fma(x,y,2.0)`.

* Solution

.play _code/fma.go

* Arrays and Slices

So far we've seen how to declare and use variables of builtin types (`int`, `float64`, ...)

But in real life, we usually have to deal with variables of more than just one value: a collection of values (of the same type.)

_E.g.:_ a collection of energy deposits in a calorimeter, a collection of hits positions in a tracker, the list of names of a students' class, etc...

In [[https://golang.org][Go]], collections of items come in two flavours:

- static arrays: arrays whose number of elements are known and *fixed* at compile time
- dynamic arrays: arrays whose number of elements are not known beforehand and can be resized at run time.

* Arrays

Arrays in Go are static arrays.
Their size is fixed and can not be neither extended nor shrunk.

 var a [10]int
 var b [1]float64
 var c = [3]int{1, 2, 3}
 d := [3]int{10, 20, 30}
 e := [...]int{10, 20, 30}

One can access the first element of an array `arr` with:

 arr := [10]int{0, 2, 4, 6, 8, 10, 12, 14, 16, 18}
 e1 := arr[0] // first element. value==0

One can also use the builtin function `len` to retrieve the size of an array:

 size := len(arr) // here, size==10

So to access the last element of an array:

 e10 := arr[len(arr)-1] // value==18

* 

Write a new program, in `~/go/src/arr/main.go`, that creates an array of 3 unsized integers, from 10 to 12.
Print each element of the array and then modify the element at index 1 to the new value 42.
Re-print each element of the array.

The program shall print:

 arr[0]= 10
 arr[1]= 11
 arr[2]= 12
 arr[0]= 10
 arr[1]= 42
 arr[2]= 12

* Solution

.play _code/arr.go

* Slices

Slices in Go are dynamic arrays.
Their size is not necessarily known at compile time and can change during the execution of the program.

 var a []float64             // a slice with 0 element
 var b = []int{1, 2, 3}      // a slice with 3 elements
 c := []int{10, 20, 30}      // a slice with 3 elements
 var d = make([]float64, 10) // a slice with 10 elements (all zeros)
 e := make([]float64, 10)    // a slice with 10 elements (all zeros)

`make` is a builtin function of [[https://golang.org][Go]] that allocates the needed memory to hold the requested number of elements of the given type:

 slice := make([]T, nelemts)

* 

Element access and modification are performed the same as for arrays:

 a := []int{0, 2, 4, 6, 8, 10, 12, 14, 16, 18}
 e1 := a[0] // first element. value == 0
 size := len(a) // ==10
 a[1] = 42

To add a new element at the end of a slice:

 a = append(a, 20)
 size = len(a) // ==11
 a = append(a, 22, 24)
 size = len(a) // ==13

* 

One can also sub-slice a slice (take a sub-sample of the original slice):

 a := []int{1, 2, 3, 4, 5}
 b := a[1:3]           // == {2, 3}
 c := a[0:2]           // == {1, 2}
 d := a[:3]            // == {1, 2, 3}
 e := a[1:]            // == {2, 3, 4, 5}
 f := a[:]             // == {1, 2, 3, 4, 5}

*NOTE:* a slice and its sub-slice *share* the same underlying backing array:

 a := []int{1, 2, 3, 4}
 b := a[1:3]  // == {2, 3}
 b[0] = 3
 println(b[0], b[1])       // 3 3
 println(a[0], a[1], a[2]) // 1 3 3

* 

Write a new program, in `~/go/src/sli/main.go`, that creates an empty slice of `float64` and then appends 3 new values: `1.2`, `3.4` and `5.6`.
Print the 3 values, increase `sli[2]` by `1` and reprint the values.

The program shall display:

  sli[0]= +1.200000e+000
  sli[1]= +3.400000e+000
  sli[2]= +5.600000e+000
  sli[0]= +1.200000e+000
  sli[1]= +3.400000e+000
  sli[2]= +6.600000e+000

What does happen if you try to access `sli[3]` ?

* Solution

.play _code/sli.go

* Control flow structures

So far our programs have been pretty boring and linear.
They were a very straightforward list of instructions, that the CPU would execute one after the other.
Very predictable. Very linear.

But in real life, we usually want our programs to do different things depending on the value(s) of some variable(s).

This is achieved with an `if`-statement.

 if len(array) > 10 {
   println("array is big")

 } else if len(array) == 1 {
   println("array length is just one")
 
 } else {
   println("array is rather small")
 }

* Solution

.play _code/if-else.go

* Control flow structures

Another useful control flow structure is the `for`-loop:

 for i := 0; i < 10; i++ {
     println("i=", i)
 }

or, the version iterating on a slice:

 vs := []int{0, 2, 4, 6, 8}
 for i := range vs {
     println("i=", i, "==>", vs[i])
 }

or:

 vs := []int{0, 2, 4, 6, 8}
 for i, v := range vs {
     println("i=", i, "==>", v)
 }

* 

.play _code/for-loops.go

* 

Write a new program, in `~/go/src/for-loop/main.go`, that will define a function `squares` that:

- takes an integer `n` as input
- returns a slice of length `n` and content the squares of the index

Create another function `sum` that takes a slice of integers and returns the sum of all the elements of the input slice.

Edit `main` so that it calls `sum` for all the integers from `0` to `20` (excluded) and prints both the argument of `sum` and the result of `sum`.

* Solution

.play _code/for-loop-sum.go /START/,/END/
 
* 

Write a new program, in `~/go/src/sum-even/main.go`, that defines a function `sum` that:

- takes a slice of integers as input
- returns the sum of all the even elements from that input slice

Edit `main` so that it calls `sum` for all the integers from `0` to `20` (excluded), generates a slice of integers from `0` to `i`, and prints the value of `i` and the result of `sum(slice)`.

* Solution

.play _code/sum-even.go /START/,/END/

* Packages and functions

So far, we've only seen how to create a single binary application/program.
We compiled that one `main.go` file (through `go` `run`) and ran.

Everything we needed for our `main` function was defined inside `main.go`.

In real life, we'd rather:

- create re-usable pieces of functionalities
- group them by theme and package them as libraries (_a.k.a.:_ `"packages"` in Go)

Then, people can `import` these libraries and the functions defined there in their own programs (or libraries.)

The [[https://golang.org][Go]] programming language comes with a rather large set of packages, usually called the "standard library" (_a.k.a.:_ "stdlib".)

* Standard library

The documentation for [[https://golang.org][Go]]'s standard library is available on:

.link https://golang.org/pkg

It's quite extensive.

Let's inspect and use the `"math"` and `"fmt"` package:

.link https://golang.org/pkg/math
.link https://golang.org/pkg/fmt

* 

.play _code/stdlib-pkg.go

* Package

Let's create our first package.

Create a new file `~/go/src/uca.fr/ints/ints.go` with the following content:

.code _code/ints-pkg.go

* 

Now, create a new program in `~/go/src/sum-2/main.go`, and edit `main` such that:

- it creates a slice of `20` elements, calling `ints.Gen(20)`,
- it prints its content
- it prints the result of calling `ints.Sum(slice)`, using the `"fmt"` package from the standard library.

_NB:_ importing our `"ints"` package is done like so:

 import "uca.fr/ints"

* Solution

.play _code/use-ints-pkg.go

* 

As a simple way to play with functions and loops, implement the square root function using Newton's method.

In this case, Newton's method is to approximate Sqrt(x) by picking a starting point z and then repeating:

.image _figs/newton.png

To begin with, just repeat that calculation 10 times and see how close you get to the answer for various values (1, 2, 3, ...).

Next, change the loop condition to stop once the value has stopped changing (or only changes by a very small delta).
See if that's more or fewer iterations.
How close are you to the `math.Sqrt`?

* 

.code _code/newton-start.go

* Solution

.play _code/newton-s1.go
.image _figs/newton.png

* Solution

.play _code/newton-s2.go /START/,/END/
.image _figs/newton.png

* Interlude: Monte Carlo simulations

.link https://en.wikipedia.org/wiki/Monte_Carlo_method

Monte Carlo methods are useful for simulating systems with many coupled degrees of freedom.
In many HEP experiments, we use [[http://geant4.cern.ch/][GEANT]] to simulate the interactions of particules through detectors.
`GEANT` simulates step-by-step the interactions of particules through matter and the energy deposits.

The simulation of physics processes with GEANT is very detailed but, also, very CPU hungry.
(That's why we usually run so called "fast simulation" programs, with a less detailed description of the physics processes.)

Let's do that.

* Introduction to Monte Carlo methods

We'll first try to approximate Pi using the Monte-Carlo method.

Consider a circle inscribed in a unit square.
Given that the circle and the square have a ratio of areas that is π/4, the value of  π can be approximated using a Monte-Carlo method:

- draw a square, inscribe a circle within it,
- uniformly scatter objects of uniform size over the square,
- count the number of objects inside the circle and the total number of objects,
- the ratio of the inside-count and the total-sample-count is an *estimate* of the ratio of the two areas, which is π/4.

Multiply the result by 4 to estimate π.


* 

Let's write a new program under `~/go/src/mc-pi/main.go`, starting with:

.code _code/mc-pi-start.go

* 

Have a look at the documentation of `math/rand` (for drawing random numbers):

.link https://golang.org/pkg/math/rand

Then, try with different values for `n`:

 $> go run ./main.go -n 10
 $> go run ./main.go -n 1000
 $> ...

* Solution

.play _code/mc-pi.go

*

Let's add some graphics:

.link https://godoc.org/github.com/master-pfa-info/mcpi

The `mcpi` package is a rather simple package that draws `(x,y)` points in the plane `((0,0), (1,1))`.


* 

Let's add some graphics and (limited) interactivity to our program.

We'll use the [[https://godoc.org/github.com/master-pfa-info/mcpi][master-pfa-info/mcpi]] package to plot the `(x,y)` points inside our quarter of a circle.

.link https://github.com/master-pfa-info/mcpi

As the documentation in the link above says, we need to install that library, using the following command (in the shell):

 $> go get github.com/master-pfa-info/mcpi

* 

Modify the previous program to plot the `(x,y)` points, using the `mcpi.Plot(x,y)` function:

.code _code/mc-pi-plot-start.go

* 

.image _figs/mc-pi.png 600 _

* Pointers & Structs

* Pointers

[[https://golang.org][Go]] supports one more builtin type: pointers.

A pointer is a variable whose value contains the address of another variable:

.play _code/ptr-0.go

* 

.play _code/func-no-ptr.go

* Interlude: implementing a calculator

* 

Let's create a new program, `~/go/src/calc/main.go`.
Our calculator will take numbers (integers) from the command line and will display their sum:

  $> cd ~/go/src/calc
  $> go build
  $> ./calc 1 2 3 4 100
  sum= 110

So far, all our programs were nice little isolated islands: they working by themselves, displaying output informations with minimal to no interactions with the outside world.

How can we somehow "connect" data from the outside with our program?

One way is to pass information from the outside via the command line, when the program is invoked.

* os.Args

In [[https://golang.org][Go]], arguments given to the program when invoked are accessible via the `os.Args` slice of strings:

 $> go doc os.Args
 var Args []string
     Args hold the command-line arguments, starting with the program name.

Let's start with:
.play _code/calc-01.go

* 

Try:

 $> go build
 $> ./calc
 args: 1
 args[0] = "./calc"

 $> ./calc 1 2 foo 42.3 bar
 args: 6
 args[0] = "./calc"
 args[1] = "1"
 args[2] = "2"
 args[3] = "foo"
 args[4] = "42.3"
 args[5] = "bar"

* 

Let's modify `main.go` to also print the argument type (with `"%T"`):

.play _code/calc-02.go

* 

  $> ./calc 1 2 foo 42.3 bar
  args: 6
  args[0] = "./calc" (string)
  args[1] = "1" (string)
  args[2] = "2" (string)
  args[3] = "foo" (string)
  args[4] = "42.3" (string)
  args[5] = "bar" (string)

So for our calculator project, we need to somehow convert the strings to integers.

In [[https://golang.org][Go]] this can be done with the [[https://golang.org/pkg/strconv][strconv]] package from the stdlib:

  v, err := strconv.Atoi("42")
  if err != nil {
      panic(err)
  }

Don't fret about the `err` and the `panic` for now.
We'll come back to this in the next chapter.

* 

So now, go write the calculator!

It should behave like so:

  $> cd ~/go/src/calc
  $> go build
  $> ./calc 1 2 3 4 100
  sum= 110

* Solution

.code _code/calc-03.go

* 

We know have a great tool at our disposal.
But it's quite blunt:

- no way to ask help and usage
- no way to customize its behaviour (_e.g.:_ enable a verbose mode)

We need a way to pass parameters, "flags", that can tweak the runtime behaviour of our great calculator, like we did with:

 $> ls -l
 $> ls -F
 $> find . -type d

In [[https://golang.org][Go]], this can be done with the [[https://golang.org/pkg/flag][flag]] package.

* 

A typical usage would look like:

.code _code/flag-pkg.go

* 

 $> go build -o flag-ex ./flag-example.go
 $> ./flag-ex
 verbose=   false
 pt-min=    25.000000
 b-tag=     2
 os.Args=   [./flag-ex]
 flag.Args= []
 
 $> ./flag-ex -btag 3 -v -pt-min=0.1 foo bar
 verbose=   true
 pt-min=    0.100000
 b-tag=     3
 os.Args=   [./flag-ex -btag 3 -v -pt-min=0.1 foo bar]
 flag.Args= [foo bar]

 $> ./flag-ex -h
 Usage of ./flag-ex:
   -btag int
     	number of b-tag for H->bb analysis (default 2)
   -pt-min float
     	min Pt cut for H->bb analysis (default 25)
   -v	enable verbose mode

* 

Now, modify our super calculator so that it accepts a `"-v"` flag that enables a verbose mode (and is false by default):

 $> ./calc 1 2 3 4 100
 sum= 110

 $> ./calc -v 1 2 3 4 100
 0
 + 1 -> 1
 + 2 -> 3
 + 3 -> 6
 + 4 -> 10
 + 100 -> 110
 ===============
 sum= 110


* Solution

.code _code/calc-04.go /^func main/,/^}/ HLflag

* Structs

* Interlude: Lorentz vectors

* Lorentz vectors

How would you create a library that would deal with Lorentz vectors ?

* 

Using 4 variables ?

  var px, py, pz, e float64

Then perhaps, the functions to compute the mass and add 2 4-vectors:

  func mass(px, py, pz, e float64) float64 {
      m2 := e*e - (px*px + py*py + pz*pz)
      return math.Sqrt(m2)
  }

  func add(px1, py1, pz1, e1, px2, py2, pz2, e2 float64) (px, py, pz, e float64) {
      return px1+px2, py1+py2, pz1+pz2, e1+e2
  }

But then you have to carry around those 4 `float64` everywhere together.

* 

What if you want to compute the invariant mass of 2 particles, say a `Z` ⟶ `bb` ?

You need:

  var b1px, b1py, b1pz, b1e float64 // b-jet #1
  var b2px, b2py, b2pz, b2e float64 // b-jet #2

and then:

  zpx, zpy, zpz, ze := add(b1px, b2px, b1py, b2py, b1pz, b2pz, b1e, b2e) // OOPS. BUG.
  invMass := mass(zpx, zpy, zpz, ze)


* 

Or perhaps using an array of 4 `float64` ?

  var p4 [4]float64

  func mass(p [4]float64) float64 {
      m2 := p[3]*p[3] - (p[0]*p[0] + p[1]*p[1] + p[2]*p[2])
      return math.Sqrt(m2)
  }

  func add(p1, p2 [4]float64) [4]float64 {
      return [4]float64{p1[0]+p2[0], p1[1]+p2[1], p1[2]+p2[2], p1[3]+p2[3]}
  }


* 

Our `Z` ⟶ `bb` example becomes:

  var (
     b1, b2 [4]float64

     z       = add(b1, b2)
     invMass = mass(z)
  )

But then, how do you make sure everybody is using the same convention ?

  [4]float64 == {px, py, pz, ene}

and not, _e.g.:_

  [4]float64 == {ene, px,  py,  pz}
  [4]float64 == {ene, eta, phi, mass}
  [4]float64 == {pt,  eta, phi, mass}
  ...

We need a way to bundle multiple values together *and* still attach some meaning (or give context) to these values...

* Structs

In [[https://golang.org][Go]] (and other languages), this task can be addressed with a `struct`:

  type P4 struct {
      Px, Py, Pz, E float64
  }

  func mass(p P4) float64 {
      m2 := p.E*p.E - (p.Px*p.Px + p.Py*p.Py + p.Pz*p.Pz)
      return math.Sqrt(m2)
  }

  func add(p1, p2 P4) P4 {
      return P4{p1.Px+p2.Px, p1.Py+p2.Py, p1.Pz+p2.Pz, p1.E+p2.E}
  }

* 

Like for the other declarations, the new type declaration of a struct is:

  type [[new-name]] struct { [[definition]] }

Fields of a struct can be of different types:

  type P4 struct { Px, Py, Pz, E float64 }
  type RecoParticle struct {
      Momentum P4          // reconstructed momentum of the particle
      Charge   float64     // charge of the particle
      AlgName  string      // algorithm that reconstructed the particle
      PDGID    int         // Particle Data Group ID
      McTruth  *McParticle // pointer to MonteCarlo truth (simu-only)
  }

A struct can also have no field:

  type Empty struct {}

* 

Let's write a program that can handle planar geometry (_ie:_ 2D).

Create a package (not a program), named `geo2d` under `~/go/src/uca.fr/geo2d/geo.go`.

In that package, create 2 structs:

- a structure named `Point` with 2 fields of type `float64` that will store the `X` and `Y` coordinates of the Point,
- a structure named `Rect` with 3 fields: the `Orig` (the bottom-most, left-most corner of the rectangle), the `Width` and the `Height` of the rectangle.

  +-----------+
  |<--Width-->| ^
  |           | Height
  |           | v
  +-----------+
  Orig

* 

Implement:

  // Translate returns a new Point translated by dx and dy
  func Translate(pt Point, dx float64, dy float64) Point { ... }

  // Area returns the area of the given rectangle
  func Area(rect Rect) float64 { ... }
  
  // Perimeter returns the perimeter of the given rectangle
  func Perimeter(rect Rect) float64 { ... }

  // Contains returns whether the given rectangle contains the given point
  func Contains(rect Rect, pt Point) bool { ... }

  // Overlap returns whether 2 rectangles overlap
  func Overlap(r1, r2 Rect) bool { ... }


* 

To test your package `geo2d` actually works, run the following program:

.play _code/geo2d-test.go

* Solution

.code _code/geo2d.go /START/,/END/

* Solution

.code _code/geo2d.go /STARTFUNCS/,/ENDFUNCS/


* I/O

* Working with files

Programming languages provide a way to:

- create files,
- open files for read-access,
- open files for write-access,
- iterate over the content of a file on disk (and possibly modify that content.)

In [[https://golang.org][Go]], this is done (mostly) with the [[https://golang.org/pkg/os][os]] package.

  f, err := os.Open("data.txt")
  if err != nil {
      panic(err)
  }

On the disk, a file is just a sequence of `bytes`.

Quite naturally, [[https://golang.org][Go]] will represent this data (to be read from a file or written to a file) as a `[]byte`, a slice of `bytes`.


* 

Let's create a new program `~/go/src/create-file/main.go` with the following content:

.code _code/create-file.go HLxxx

* 

Running this program should give:

 $> go run ./main.go
 
 $> cat data.txt
 hello world
 0 1 2 3 4 5
 good bye

Creating/opening a file, writing to the file, reading from the file and/or closing the file *MAY* fail for some reason (not enough disk space, corrupted filesystem, broken hard disk, no more network connection, etc...)

That's why most of the function that deal with files return this extra `err` value (of type `error`.)

We'll see in more details what an `error` type is in the chapter about `interfaces`.
For now, remember to always `Close()` your files whenever you've opened them (for reading or writing), and always check whether that `error` value is not `nil`.

* 

Let's modify `~/go/src/create-file/main.go` like so:

.code _code/create-file-floats.go

* 

Running this program should give:

 $> go run ./main.go

 $> head -n 4 data.txt
 -1.233758177597947
 -0.12634751070237293
 -0.5209945711531503
 2.28571911769958

 $> wc ./data.txt 
  1000  1000 19671 ./data.txt


Now create yet another program, `~/go/src/read-file/main.go` with the following content (see next slide.)

* 

.code _code/read-file-floats.go /^func main/,/^}/

* 

Copy the `data.txt` file created previously into the current directory.
Running our new program should give:

 $> go run ./main.go
 mean= -0.013051

* 

Hard-coding the number of times to loop over the lines in the input file isn't quite satisfactory.

Let's try to fix that.
In [[https://golang.org][Go]], there is a special type that can scan lines of a file and iteratively present each line as an API:

  f, err := os.Open("some-file.txt")
  if err != nil { panic(err) }
  scan := bufio.NewScanner(f)  // need to import "bufio"

  for scan.Scan() {
    txt := scan.Text() // returns a string with the content of current line.
    fmt.Printf("we've read line %q\n", txt)
  }

  if err = scan.Err(); err != nil { panic(err) }
  if err = f.Close();  err != nil { panic(err) }

.link https://golang.org/pkg/bufio#Scanner

* 

Wielding this new tool at our disposal, let's modify the previous program (`read-file/main.go`) to not hard-code the number of times/lines to loop over when reading the input file.

In the previous version of that program, we used `fmt.Fscanf` to extract a `float64` out of the file.
Now we need to extract a `float64` out of a line (which is a `string`.)

We'll need to use a slightly different function to do that: `fmt.Sscanf`.

.link https://golang.org/pkg/fmt#Sscanf

 for scan.Scan() {
     var f64 float64
     var txt = scan.Text()
     _, err = fmt.Sscanf(txt, "%f", &f64)
     if err != nil { panic(err) }
 }

* 

Make sure we still get the same answer when running the new version of the program:

 $> go run ./main.go
 mean= -0.013051


* Solution

.code _code/read-file-floats-bufio.go /^func main/,/^}/

* 

Create a new program `~/go/src/write-2d-gauss/main.go`.
It should create a new `data-2d-gauss.txt` file containing 2 columns of data.

Each column should be a 1000-sample of (respectively):

- a gaussian with mean 20 and standard deviation 5
- a gaussian with mean 10 and standard deviation 20.

Create another program `~/go/src/read-2d-gauss/main.go`, that will:

- read the previously created `data-2d-gauss.txt` file,
- store the data for each column in a dedicated slice of `float64`,
- define 2 functions `mean` and `stddev` that take a `[]float64` slice as input and return (respectively) the mean and the standard deviation of the slice.

Make sure you get the expected mean and stddev values for each sample.

* Solution

.code _code/write-2d-gauss.go /^func main/,/^}/

* Solution

.code _code/read-2d-gauss.go /var g1/,/^}/

* Solution

.code _code/read-2d-gauss.go /^\/\/ mean/,/^}/
.code _code/read-2d-gauss.go /^\/\/ stddev/,/^}/

* 

Let's revisit our super calculator.

Modify the calculator to be able to sum `float64` values (and not just `int` as previously.)

Add 2 new flags:

 var flagFile = flag.String("f", "", "path to a file holding values")
 var flagStats = flag.Bool("stats", false, "enable computation+display of stats")

Modify the calculator to be able to optionally take a path to a file (with `-f=my-file.txt`) and then take data from that file instead of from the command line like previously.

Make sure that it still works as previously when no `-f` flag is passed (_ie:_ when `*flagFile==""`).

Use a `bufio.Scanner` to read the (optional) input file.

* 

Modify the calculator to compute the mean and standard deviation of the input data when the `-stats` flag is passed to the program.
When that flag is passed, the calculator should display the mean and std-dev of the sample at the end of the program.
It should work for both modes (when `*flagFile==""` and when a path to a file is given to the program.)

* Solution

.code _code/calc-05.go /^func main/,/^}/

* Solution

.code _code/calc-05.go /^func run/,/^}/

* Solution

.code _code/calc-05.go /^func readFile/,/^}/

* Solution

.code _code/calc-05.go /^func readArgs/,/^}/

* Object Oriented Programming

* Structs, Types & Methods

Do you remember the Lorentz vectors we defined earlier ?

  type P4 struct {
      Px, Py, Pz, E float64
  }

  func mass(p P4) float64 {
      m2 := p.E*p.E - (p.Px*p.Px + p.Py*p.Py + p.Pz*p.Pz)
      return math.Sqrt(m2)
  }

  func add(p1, p2 P4) P4 {
      return P4{p1.Px+p2.Px, p1.Py+p2.Py, p1.Pz+p2.Pz, p1.E+p2.E}
  }

* 

Let's modify it a little bit:

  type PxPyPzE struct {
      px, py, pz, e float64
  }

  func mass(p PxPyPzE) float64 {
      m2 := p.e*p.e - (p.px*p.px + p.py*p.py + p.pz*p.pz)
      return math.Sqrt(m2)
  }

  func add(p1, p2 PxPyPzE) PxPyPzE {
      return PxPyPzE{p1.px+p2.px, p1.py+p2.py, p1.pz+p2.pz, p1.e+p2.e}
  }

and add:

  type PtEtaPhiM struct {
      pt, eta, phi, m float64
  }

* 

When we add another Lorentz vector type (with different components) we have a problem:

- we can't call the `mass(...)` function with a `PtEtaPhiM` value.

We could define 2 functions:

 func massPxPyPzE   (p PxPyPzE  ) float64 { ... }
 func massPtEtaPhiM (p PtEtaPhiM) float64 { ... }

But we can do better: define methods on each type `PxPyPzE` and `PtEtaPhiM`:

 func (p PxPyPzE)   Mass() float64 { /* as previously */ }
 func (p PtEtaPhiM) Mass() float64 { return p.m }

What did we gain here ?

* 

.play _code/hlv-main.go /^func main/,/^}/ HLxxx
.play _code/hlv-main-meth.go /^func main/,/^}/ HLxxx

* 

We can also define a new method on the type `PxPyPzE`:

.play _code/hlv-main-meth-stringer.go /^func \(p PxPyPzE\) String\(/,/^}/

and then:

.play _code/hlv-main-meth-stringer.go /^func main/,/^}/ HLxxx

* 

What did just happen ?

The `fmt.Printf` function managed to call the method `String()` of our `PxPyPzE` value.
When `fmt.Printf` was written (~10 years ago),

- it didn't know a type like `PxPyPzE` would ever be written,
- it didn't even know it would have a method with that name and signature!

Yet, somehow it knew it had to call `String()` on our `z` value...

Well... that's because `fmt.Printf` used an *interface* and because our `PxPyPzE` (implicitly) implemented it.

* Interfaces

An interface type is defined as a set of method signatures.

A value of interface type can hold any value that implements those methods.

  type Abser interface {
      Abs() float64
  }
  
  type Reader interface {
      Read(data []byte) (int, error)
  }


_E.g.:_ the type `MyFloat` implements the `Abser` interface:

  type MyFloat float64
  
  func (f MyFloat) Abs() float64 {
  	if f < 0 {
  		return float64(-f)
  	}
  	return float64(f)
  }

* Interfaces

Modify the code below to make `MyFloat` and `Vertex` implement the `Abser` interface:

.play _code/ex-interfaces.go /STARTABSER OMIT/,/ENDABSER OMIT/

* Solution

.play _code/ex-interfaces.go /STARTABSERIMPL OMIT/,/ENDABSERIMPL OMIT/

* 

Interfaces are useful to write code that can use code that hasn't been written yet.

  func Selector(a Abser) bool {
      if a.Abs() > 2.5 {
          return true
      }
      return false
  }

  func do() {
    Selector(MyFloat(42))    // this compiles.
    Selector(&Vertex{1,2})   // this also compiles.
    Selector(Vertex{1,2})    // but this does NOT compile.
  }


The `Selector` function can be used with values of types `MyFloat`, `Vertex` or any other type (possibly one written 15 years from now) that implements the `Abser` interface.

And no need to modify nor adapt the `Selector` function to get it working with these new types, as long as they implement the `Abser` interface.

It's a contract that binds the 2 parties (the interface and the type that implements that interface.)

* 

Let's revisit our `geo2d` package.

We had defined 2 types: `Point` and `Rect`.

Let's introduce 1 new type: `Circle`.

Define 2 new interfaces:

  type Surfer interface {
      // Surf returns the surface of a 2D shape
      Surf() float64
  }

  type Stringer interface {
      // String returns a string reprensation of a value.
      String() string
  }

* 

Modify `geo2d` such that `Point`, `Rect` and `Circle` implement the `Stringer` interface.

Modify `geo2d` such that `Rect` and `Circle` implement the `Surfer` interface.

Finally, modify the `geo2d.Area` function to take a `Surfer` parameter instead of a `Rect`.

Test that you can then pass to `geo2d.Area`:

- a value of type `Circle` and,
- a value of type `Rect`.

* Solution

.code _code/geo2d-iface.go /STARTSTRINGER/,/ENDSTRINGER/

* Solution

.code _code/geo2d-iface.go /STARTSURFACER/,/ENDSURFACE/

* 

Interfaces are a very powerful abstraction.

So much so that [[https://golang.org][Go]] uses one to flag errors; the [[https://golang.org/pkg/builtin#error][error]] interface:

  type error interface {
      Error() string
  }

That interface was deemed so useful that it is now part of the set of builtin types and functions of the Go language.

Interfaces are actually one of the building blocks of OO-programming in Go.




* OOP

.link https://en.wikipedia.org/wiki/Object-oriented_programming

 Object-oriented programming (OOP) is a programming paradigm based on the concept of "objects",
 which may contain data, in the form of fields, often known as attributes;
 and code, in the form of procedures, often known as methods.

The "classical" definition of an OOP language relies on 3 features:

- Polymorphism
- Encapsulation
- Inheritance

OOP is a bit like landing a role in a Hollywood production: "don't call us, we'll call you".

You setup and implement the needed interface(s) for your type(s) and you can then have your type(s) being used and integrated with the overall surrounding framework.

* 

Let's see how we can implement an I/O interface.
Let's create a new `rot13` package, in `~/go/src/uca.fr/rot13`.

`rot13` will implement the Caesar cipher ("rotate by 13 places"):

.link https://en.wikipedia.org/wiki/ROT13

We'll start with a `rot13.go` file that looks like:

 package rot13

 func rot13(b byte) byte {
     // ...
 }

- under this `rot13` transformation, `"hello"` should become `"uryyb"`

* 

- in that `rot13` package, create `rot13_test.go` with the following content:

.code _code/rot13_test.go /STARTIMPORT OMIT/,/ENDIMPORT OMIT/ HLxxx

* 

- in that `rot13` package, create `rot13_test.go` with the following content:

.code _code/rot13_test.go /^func TestRot13/,/^}/ HLxxx

* 

So now, we can start to implement the `rot13` function and make sure it passes all the tests:

  $ go test -v
  === RUN TestRot13
  --- PASS: TestRot13 (0.00 seconds)
  PASS
  ok  	uca.fr/rot13	0.002s
  
- `go` `test` builds and runs the tests in the local directory.

* Solution

.code _code/rot13.go /STARTROT13-FUNC OMIT/,/ENDROT13-FUNC OMIT/

* 

We've seen and implemented the `Abser`, `Surfer` and `Stringer` interfaces.

Our `Stringer` interface is actually a cousin of the one living in the `fmt` package: `fmt.Stringer` (that's why we had our types implementing it being able to be printed correctly with `fmt.Printf`).

Another very used (and useful) interface is `io.Reader` (which lives in the [[https://golang.org/pkg/io][io]] package):

  // Reader is the interface that wraps the basic Read method.
  type Reader interface {
     Read(p []byte) (n int, err error)
  }

`io.Reader` is at the basis of all the input operations in [[https://golang.org][Go]] and thus at the basis of how [[https://golang.org][Go]] interacts with files and the operating system.

* 

Let's try to integrate our very useful `rot13` function with the I/O system.
Let's write another program, `~/go/src/caesar-cipher/main.go`:

.code _code/caesar-cipher.go HLxxx

* 

Now, in `"uca.fr/rot13"`, implement the `io.Reader` interface:

.code _code/rot13.go /STARTROT13 OMIT/,/ENDROT13 OMIT/

  func (r reader) Read(p []byte) (int, error) {
       // ...
  }

- eventually, the following should work:

  $> cd caesar-cipher
  $> go build
  $> echo "hello" | caesar-cipher
  uryyb

  $> echo "hello" | caesar-cipher | caesar-cipher
  hello


* Solution

.code _code/rot13.go /STARTROT13SOLUTION OMIT/,/ENDROT13SOLUTION OMIT/

* Polymorphism

So, our `rot13.reader` type implements the `io.Reader` interface, and can be used as an `io.Reader` value, _i.e._ as a parameter of the `io.Copy` function:

  $> go doc io.Copy
  func Copy(dst Writer, src Reader) (written int64, err error)
      Copy copies from src to dst until either EOF is reached on src or an error
      occurs. It returns the number of bytes copied and the first error
      encountered while copying, if any.

That's *polymorphism*: the ability of different values (or objects) to respond, each in its own way, to identical messages.

Remember our `geo2d.Circle` and our `geo2d.Rect` types ?
They both implemented the `geo2d.Surfer` interface by implementing (in their own way) the computation of their surface.
That's polymorphism.

* Encapsulation

*Encapsulation* is the concept that binds together the data *and* the functions that manipulate that data, and that keeps both safe from outside interferences (and misuses.)

* 

In Go, we can achieve encapsulation at the package level.

 package foo // file: go/src/my-pkgs/foo/file1.go

 type Point { X float64; c int }
 func (p Point) Color() int { return p.c }
 func (p Point) move() { ... }

 func F(v float64) { ... }
 func g(v float32) { ... }
 
 var Exported = 42
 var private = 42

Inside package `foo`, one can access all the data encapsulated by the type `Point`.
We can also use the functions `F()` and `g()`, or the methods `Color()` and `move()`.

Outside of package `foo`, users importing `"my-pkgs/foo"` can only use `Point`, `Move()` and `F()` as their name start with an upper case letter: these identifiers are *exported*.

This mechanism also works for fields of the type `Point`: outside of the package `foo`, users can only access and/or modify the field `X` but not the field `c`.

* 

With encapsulation, we could revisit our `geo2d.Rect` like so:

.code _code/geo2d-encapsulated.go /STARTTYPES/,/ENDTYPES/

* 

With encapsulation, we are sure the rectangles that are created will be real rectangles (and not just some polygon with 4 points).

And with this new `Rect` type, we can support rectangles that are rotated by some angle: this wasn't possible with the original design.

Also, now that the internals and the minute details of `Rect` are hidden, potential users won't rely on them nor be able to use them: we are free to modify them without impacting these users.

* Inheritance

.link https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)

 inheritance is when an object or class is based on another object (prototypal
 inheritance) or class (class-based inheritance), using the same implementation.

Inheritance is usually a mechanism for code re-use: the class `Derived` inheriting from the class `Parent`, inherits (some of) its methods.

In Go, there is no "real" inheritance.
But we can somewhat "fake" it with _embedding_:

.code _code/embedding.go HLxxx

* Concurrency programming

* Interlude: Sequential, Concurrent & Parallel pizzas

* Pizza recipe

(*Disclaimer:* don't ever eat any pizza prepared or cooked by me.)

How to prepare a (sequential) pizza?

.code _code/make-pizza.f

Estimated time (1 chef, 1 pizza):

  xx-oooo-xxx-oo-###

How to make this faster?

* (Sequential) Pizza recipe
 
Tasks:

- wash tomatoes and onions
- cut tomatoes, onions
- prepare pizza dough
- put tomato sauce on top of pizza dough
- toppings: put tomatoes, onions, ham and mozarella
- (pre-)heat oven, bake
- (cut, then eat)

Estimated time (1 chef, 1 pizza):

  xx-oooo-xxx-oo-###

* Concurrent pizzas - Parallel pizzas

Estimated time (1 chef, 1 kitchen, 2 pizzas):

  xx-oooo-xxx-oo-###-xx-oooo-xxx-oo-###

Estimated time (1 chef, 2 kitchens, 2 pizzas):

  xx-oooo-xxx-oo+###
                +xx-oooo-xxx-oo-###

Estimated time (2 chefs, 1 kitchen, 2 pizzas):

  xx-xxx-+-xx-xxx-+
         +###     +###
  oooo-oo+-oooo-oo+

Estimated time (2 chefs, 2 kitchens, 2 pizzas):

  xx-oooo-xxx-oo-###
  xx-oooo-xxx-oo-###

* Interlude: concurrency & parallelism

- *Concurrency* is about _dealing_ with lots of things at once.
- *Parallelism* is about _doing_ lots of things at once.
- Not the same, but related.
- Concurrency is about _structure_, parallelism is about _execution_.

.image _figs/conc-para.png 200 600

Concurrency is a way to structure a program by breaking it into pieces that can be executed independently.
Communication is the means to coordinate the independent executions.

* Concurrency vs Parallelism

Concurrency is about dealing with lots of things at once.
Parallelism is about doing lots of things at once.

Concurrency is about (program) *structure*.
Parallelism is about (program) *execution*.

.image _figs/conc-vs-par-prog.png 300 _

Concurrency is *not* parallelism, it's better :)

* Concurrency plus communication

Concurrency is a way to structure a program by breaking it into pieces that can be executed independently.

Communication is the means to coordinate the independent executions.

This is the Go model and (like Erlang and others) it's based on CSP:

C. A. R. Hoare: Communicating Sequential Processes (CACM 1978)

* Concurrency: basic examples

* A boring function

We need an example to show the interesting properties of the concurrency primitives.
To avoid distraction, we make it a boring example.

.code _code/boring.go /START/,/STOP/

* Slightly less boring

Make the intervals between messages unpredictable (still under a second).

.code _code/lessboring.go /START/,/STOP/

* Running it

The boring function runs on forever, like a boring party guest.

.play _code/lessboring.go /^func.main/,$

* Ignoring it

The `go` statement runs the function as usual, but doesn't make the caller wait.

It launches a goroutine.

The functionality is analogous to the `&` on the end of a shell command.

.play _code/goboring.go 1,/^}/


* Ignoring it a little less

When `main` returns, the program exits and takes the boring function down with it.

We can hang around a little, and on the way show that both main and the launched goroutine are running.

.play _code/waitgoboring.go /func.main/,/^}/

* Goroutines

What is a goroutine? It's an independently executing function, launched by a go statement.

It has its own call stack, which grows and shrinks as required.

It's very cheap. It's practical to have thousands, even hundreds of thousands of goroutines.

It's not a thread.

There might be only one thread in a program with thousands of goroutines.

Instead, goroutines are multiplexed dynamically onto threads as needed to keep all the goroutines running.

But if you think of it as a very cheap thread, you won't be far off.

* Communication

Our boring examples cheated: the main function couldn't see the output from the other goroutine.

It was just printed to the screen, where we pretended we saw a conversation.

Real conversations require communication.

* Channels

A channel in Go provides a connection between two goroutines, allowing them to communicate.

.code _code/helpers.go /START1/,/STOP1/
.code _code/helpers.go /START2/,/STOP2/
.code _code/helpers.go /START3/,/STOP3/

* Using channels

A channel connects the main and boring goroutines so they can communicate.

.play _code/changoboring.go /START1/,/STOP1/
.code _code/changoboring.go /START2/,/STOP2/

* Synchronization

When the main function executes <–c, it will wait for a value to be sent.

Similarly, when the boring function executes c <– value, it waits for a receiver to be ready.

A sender and receiver must both be ready to play their part in the communication. Otherwise we wait until they are.

Thus channels both communicate and synchronize.

* The Go approach

Don't communicate by sharing memory, share memory by communicating.

* "Patterns"

* Generator: function that returns a channel

Channels are first-class values, just like strings or integers.

.play _code/generatorboring.go /START1/,/STOP1/
.code _code/generatorboring.go /START2/,/STOP2/

* Channels as a handle on a service

Our boring function returns a channel that lets us communicate with the boring service it provides.

We can have more instances of the service.

.play _code/generator2boring.go /START1/,/STOP1/

* Multiplexing

These programs make Joe and Ann count in lockstep.
We can instead use a fan-in function to let whosoever is ready talk.

.code _code/faninboring.go /START3/,/STOP3/
.play _code/faninboring.go /START1/,/STOP1/

* Fan-in

.image _figs/gophermegaphones.jpg

* Restoring sequencing

Send a channel on a channel, making goroutine wait its turn.

Receive all messages, then enable them again by sending on a private channel.

First we define a message type that contains a channel for the reply.

.code _code/sequenceboring.go /START0/,/STOP0/

* Restoring sequencing.

Each speaker must wait for a go-ahead.

.code _code/sequenceboring.go /START1/,/STOP1/
.code _code/sequenceboring.go /START2/,/STOP2/
.play _code/sequenceboring.go /START3/,/STOP3/

* Select

A control structure unique to concurrency.

The reason channels and goroutines are built into the language.

* Select

The select statement provides another way to handle multiple channels.
It's like a switch, but each case is a communication:

- All channels are evaluated.
- Selection blocks until one communication can proceed, which then does.
- If multiple can proceed, select chooses pseudo-randomly.
- A default clause, if present, executes immediately if no channel is ready.

.code _code/select.go /START0/,/STOP0/

* Fan-in again

Rewrite our original fanIn function. Only one goroutine is needed. Old:

.code _code/faninboring.go /START3/,/STOP3/

* Fan-in using select

Rewrite our original fanIn function. Only one goroutine is needed. New:

.play _code/selectboring.go /START3/,/STOP3/

* Timeout using select

The time.After function returns a channel that blocks for the specified duration.
After the interval, the channel delivers the current time, once.

.play _code/timeout.go /START1/,/STOP1/

* Timeout for whole conversation using select

Create the timer once, outside the loop, to time out the entire conversation.
(In the previous program, we had a timeout for each message.)

.play _code/timeoutall.go /START1/,/STOP1/


* Quit channel

We can turn this around and tell Joe to stop when we're tired of listening to him.

.code _code/quit.go /START1/,/STOP1/
.play _code/quit.go /START2/,/STOP2/


* Receive on quit channel

How do we know it's finished? Wait for it to tell us it's done: receive on the quit channel

.code _code/rcvquit.go /START1/,/STOP1/
.play _code/rcvquit.go /START2/,/STOP2/

* Daisy-chain

.play _code/daisy.go /func/,$

* Chinese whispers, gopher style

.image _figs/gophereartrumpet.jpg

* Conclusions

Goroutines and channels make it easy to express complex operations dealing with:

- multiple inputs
- multiple outputs
- timeouts
- failure

And they're fun to use.

* Exercize: equivalent binary trees

There can be many different binary trees with the same sequence of values stored at the leaves. For example, here are two binary trees storing the sequence 1, 1, 2, 3, 5, 8, 13.

.image _figs/tree.png

A function to check whether two binary trees store the same sequence is quite complex in most languages. We'll use Go's concurrency and channels to write a simple solution.

* 

This example uses the `"golang.org/x/tour/tree"` package, which defines the type:

 type Tree struct {
    Left  *Tree
    Value int
    Right *Tree
 }

We need to install it.
In a normal setup, we'd just have to do:

 $> go get golang.org/x/tour/tree

but, in the UCA rooms (and because of the proxy) we'll have to do instead:

 $> cd ~/go/src
 $> git clone --depth=5 https://github.com/golang/tour golang.org/x/tour

* 

Let's create the skeleton for our binary-tree exercize `~/go/src/btree/main.go`:

.code _code/btree-start.go

* 

- Implement the `Walk` function.

- Test the `Walk` function.

The function `tree.New(k)` constructs a randomly-structured binary tree holding the values `k`, `2k`, `3k`, ..., `10k`.

Create a new channel `ch` and kick off the walker:

 go Walk(tree.New(1), ch)

Then read and print 10 values from the channel. It should be the numbers 1, 2, 3, ..., 10.


- Implement the `Same` function using `Walk` to determine whether `t1` and `t2` store the same values.

- Test the `Same` function.

`Same(tree.New(1),` `tree.New(1))` should return `true`, and `Same(tree.New(1),` `tree.New(2))` should return `false`.

The documentation for `Tree` can be found [[https://godoc.org/golang.org/x/tour/tree#Tree][here]].

* Solution

.code _code/btree.go /STARTWALK/,/ENDWALK/

* Solution

.code _code/btree.go /STARTSAME/,/ENDSAME/

* Solution

.play _code/btree.go /^func main/,/^}/


* 

Actually, the presented solution contains a bug...
When the 2 trees don't have the same length, `Same` will return early:

.code _code/btree.go /STARTSAME/,/ENDSAME/ HLxxx

This will leave one of the 2 `Walk` goroutines waiting to send its values over the channel.

* 

We need to fix that.
We need to tell the 2 `Walk` goroutines that their services are no longer required.

This can be done with a `quit` channel.

* Solution

.code _code/btree-noleak.go /STARTWALK/,/ENDWALK/

* Solution

.code _code/btree-noleak.go /STARTSAME/,/ENDSAME/

* Solution

.play _code/btree-noleak.go /^func main/,/^}/

* Resources

.link https://golang-book.com
.link http://www.inf.unibz.it/dis/teaching/PP/ln/pp01_intro.pdf
.link http://www.inf.unibz.it/dis/teaching/PP/ln/pp02_oo.pdf
.link https://tour.golang.org
.link https://www.golangbootcamp.com/book

